<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complejidad en el Tiempo - Explicación Sencilla</title>
    <link rel="stylesheet" href="estructura.css">
</head>
<body>

    <h1>Complejidad en el Tiempo</h1>

    <p>
        La **complejidad en el tiempo** es una medida de la cantidad de tiempo que un algoritmo necesita para resolver un problema en función del tamaño de la entrada. Este concepto es esencial porque, en programación, a menudo necesitamos optimizar los algoritmos para que sean rápidos, especialmente cuando manejamos grandes cantidades de datos.
    </p>

    <h2>¿Qué es la Complejidad Temporal?</h2>
    <p>
        La complejidad temporal describe cómo el tiempo de ejecución de un algoritmo crece a medida que aumenta el tamaño de los datos de entrada. Cuanto más rápido crece el tiempo de ejecución, menos eficiente es el algoritmo. La forma más común de expresar la complejidad temporal es mediante la **notación Big O**, que nos da una idea de cómo se comporta el algoritmo en su peor caso.
    </p>

    <h2>Notación Big O</h2>
    <p>
        La **notación Big O** es una forma matemática de expresar la complejidad temporal de un algoritmo. Nos dice cuánto tiempo tardará un algoritmo en función del tamaño de los datos de entrada. Aquí te presentamos algunas de las notaciones más comunes:
    </p>

    <ul>
        <li><strong>O(1) - Tiempo constante:</strong> El algoritmo siempre tarda lo mismo, sin importar cuántos datos tenga que procesar. Ejemplo: acceder a un elemento en un array por su índice.</li>
        <li><strong>O(n) - Tiempo lineal:</strong> El tiempo de ejecución aumenta de forma proporcional al tamaño de la entrada. Ejemplo: recorrer una lista de elementos.</li>
        <li><strong>O(n²) - Tiempo cuadrático:</strong> El tiempo de ejecución crece de forma cuadrática con el tamaño de la entrada. Ejemplo: el algoritmo de burbuja para ordenar una lista.</li>
        <li><strong>O(log n) - Tiempo logarítmico:</strong> El tiempo de ejecución crece lentamente a medida que aumentan los datos. Ejemplo: la búsqueda binaria en un array ordenado.</li>
        <li><strong>O(n log n) - Tiempo n log n:</strong> Un algoritmo cuyo tiempo de ejecución crece más rápido que O(n) pero más lento que O(n²). Ejemplo: el algoritmo QuickSort.</li>
    </ul>

    <h2>Ejemplos de Complejidad Temporal</h2>

    <h3>1. O(1) - Tiempo Constante</h3>
    <p>
        Un algoritmo con **O(1)** de complejidad temporal significa que el tiempo de ejecución no depende del tamaño de la entrada. Es decir, el algoritmo siempre realiza el mismo número de operaciones, sin importar cuántos elementos tenga que procesar. 
    </p>
    <pre><code class="language-java">
public class EjemploO1 {
    public static void main(String[] args) {
        int[] arreglo = {1, 2, 3, 4, 5};
        System.out.println(arreglo[0]); // Accede siempre al primer elemento en tiempo constante O(1)
    }
}
    </code></pre>

    <h3>2. O(n) - Tiempo Lineal</h3>
    <p>
        Un algoritmo con **O(n)** de complejidad temporal recorre cada elemento de los datos de entrada una vez. Por ejemplo, si tienes una lista de 10 elementos, el algoritmo realizará 10 operaciones. Si la lista tiene 100 elementos, el algoritmo hará 100 operaciones, y así sucesivamente.
    </p>
    <pre><code class="language-java">
public class EjemploOn {
    public static void main(String[] args) {
        int[] arreglo = {1, 2, 3, 4, 5};
        for (int i = 0; i < arreglo.length; i++) {
            System.out.println(arreglo[i]); // Recorre cada elemento una vez
        }
    }
}
    </code></pre>

    <h3>3. O(n²) - Tiempo Cuadrático</h3>
    <p>
        Un algoritmo con **O(n²)** de complejidad temporal suele involucrar dos bucles anidados, lo que significa que el número de operaciones aumenta cuadráticamente con el tamaño de la entrada. Es más lento y menos eficiente que los algoritmos O(n).
    </p>
    <pre><code class="language-java">
public class EjemploOn2 {
    public static void main(String[] args) {
        int[] arreglo = {1, 2, 3, 4, 5};
        for (int i = 0; i < arreglo.length; i++) {
            for (int j = 0; j < arreglo.length; j++) {
                System.out.println(arreglo[i] + " " + arreglo[j]); // Dos bucles anidados, O(n²)
            }
        }
    }
}
    </code></pre>

    <h3>4. O(log n) - Tiempo Logarítmico</h3>
    <p>
        Los algoritmos con **O(log n)** de complejidad temporal son muy eficientes, ya que el tiempo de ejecución crece lentamente incluso con grandes cantidades de datos. Un buen ejemplo es la **búsqueda binaria**, que reduce a la mitad la cantidad de elementos que debe explorar en cada paso.
    </p>
    <pre><code class="language-java">
public class EjemploOlogn {
    public static void main(String[] args) {
        int[] arreglo = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int objetivo = 7;
        int inicio = 0, fin = arreglo.length - 1;

        while (inicio <= fin) {
            int medio = (inicio + fin) / 2;
            if (arreglo[medio] == objetivo) {
                System.out.println("Elemento encontrado en el índice: " + medio);
                break;
            } else if (arreglo[medio] < objetivo) {
                inicio = medio + 1;
            } else {
                fin = medio - 1;
            }
        }
    }
}
    </code></pre>

    <h2>¿Por Qué Es Importante Saber la Complejidad Temporal?</h2>
    <p>
        Conocer la complejidad temporal de los algoritmos nos ayuda a entender cuán rápido o lento es un algoritmo para resolver un problema. En la práctica, elegir el algoritmo adecuado puede marcar la diferencia entre tener un programa rápido y eficiente y tener un programa lento que no pueda manejar grandes cantidades de datos.
    </p>

    <h2>Conclusión</h2>
    <p>
        La complejidad temporal es una herramienta clave para medir y mejorar la eficiencia de los algoritmos. Aprender a analizar los algoritmos usando la notación Big O te permitirá escribir programas más rápidos y escalables. Recuerda, el objetivo es siempre elegir el algoritmo más adecuado para cada tarea, de acuerdo con el tamaño de los datos y las necesidades de rendimiento.
    </p>

    <div id="buttonContainer">
        <button id="backButton4">Volver</button>
    </div>

    <script src="../funciones.js"></script>

</body>
</html>
